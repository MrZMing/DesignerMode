# DesignerMode
## 构建者模式
#### 工厂模式
1. 作用：解耦、减少代码重复，当对象需要改变时，调用者代码不需要变
    1. 解耦：直接new调用者需要知道每个需要new的类的关系，但如果把构造方式交给工厂，则只需要跟工厂说需要哪个对象即可
    2. 减少代码重复：如构造一个对象苹果，需要树、阳光等，且构造其他水果也需要，那么这里其实很多重复代码，这种情况应该用继承来解决吧
    3. 
2. 创建对象：
    1. 新建一个工厂类，负责生产对象，简单工厂只需要一个
    2. 提供公共函数，由该函数负责生产对象，即工厂函数
    3. 创建工厂对象制定类型调用生产即可
3. 分类
    1. 简单工厂模式：只有一个工厂，提供create方法，直接用switch分之来解决，适用于简单对象
        1. 缺点：
            1. 违背单一职责：每当生产过程需要修改都需要修改工厂类
            2. 违背开闭原则：新增产品需要新增工厂类分支，而非新增类解决。
        2. UML：1676815184394.jpg
    2. 工厂模式：每个产品都有对应的专属工厂，工厂是一个抽象类，如接口类，不同的产品有自己的工厂类继承自基类工厂，实现create方法即可。调用者调用不同的工厂类的create方法。感觉可以优化下用register注册到一个map里面，然后还是用名字来调用工厂的create方法返回对象。
    需要创建N个工厂类，适用于复杂对象
        1. 好处：解决了简单工厂的问题，需要修改不同产品的生产流程只需要修改对应的类，需要新增产品也只需要继承该工厂的create方法然后实现一个类
        2. 使用场景：如果是只有几个对象需要生产则直接使用简单工厂即可。如果是考虑后续扩展及维护以及遵循设计模式原则，则直接用工厂模式
        3. 抽象工厂类，派生每个产品的工厂类，每个工厂类实现create方法新建每个产品，产品也是搞一个抽象基类
    3. 抽象工厂模式：需要创建N个工厂类,适用于复杂对象，生产产品更复杂。优化工厂模式，对产品进行进一步抽象，如家具需要抽象为不同风格，沙发，桌子，椅子，中式西式。  
        1. 场景：产品种类繁多，且产品可由不同的零部件组成，比如说抽象工厂类，中式风格工厂类，西式风格工厂类，每个风格下面需要有桌子，椅子，沙发等。桌子椅子沙发也是一个抽象基类，下面如沙发可以有中式木沙发，西式软皮沙发等。然如中式风格家具需要有中式木沙发，红木床等组合，调用者调用中式风格工厂类，create方法，返回一个中式风格家具基类，家具基类可以提供属性方法用来知道当前的组合情况是怎样的。这里家具也是一个基类，中式风格家具是一个子类，跟桌子、椅子、沙发、床等是一个组合关系
        2. ps：组合和聚合的区别是在析构的时候要不要对成员进行西沟。

